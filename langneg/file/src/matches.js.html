<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/matches.js | @fluent/langneg</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Language Negotiation API for Fluent"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@fluent/langneg"><meta property="twitter:description" content="Language Negotiation API for Fluent"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/projectfluent/fluent.js.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/locale.js~Locale.html">Locale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-acceptedLanguages">acceptedLanguages</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-filterMatches">filterMatches</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-negotiateLanguages">negotiateLanguages</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getLikelySubtagsMin">getLikelySubtagsMin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-localeParts">localeParts</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/matches.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint no-magic-numbers: 0 */
/* eslint complexity: [&quot;error&quot;, { &quot;max&quot;: 27 }] */

import Locale from &quot;./locale&quot;;

/**
 * Negotiates the languages between the list of requested locales against
 * a list of available locales.
 *
 * The algorithm is based on the BCP4647 3.3.2 Extended Filtering algorithm,
 * with several modifications:
 *
 *  1) available locales are treated as ranges
 *
 *    This change allows us to match a more specific request against
 *    more generic available locale.
 *
 *    For example, if the available locale list provides locale `en`,
 *    and the requested locale is `en-US`, we treat the available locale as
 *    a locale that matches all possible english requests.
 *
 *    This means that we expect available locale ID to be as precize as
 *    the matches they want to cover.
 *
 *    For example, if there is only `sr` available, it&apos;s ok to list
 *    it in available locales. But once the available locales has both,
 *    Cyrl and Latn variants, the locale IDs should be `sr-Cyrl` and `sr-Latn`
 *    to avoid any `sr-*` request to match against whole `sr` range.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    [&apos;en-US&apos;] * [&apos;en&apos;] = [&apos;en&apos;]
 *
 *  2) likely subtags from LDML 4.3 Likely Subtags has been added
 *
 *    The most obvious likely subtag that can be computed is a duplication
 *    of the language field onto region field (`fr` =&gt; `fr-FR`).
 *
 *    On top of that, likely subtags may use a list of mappings, that
 *    allow the algorithm to handle non-obvious matches.
 *    For example, making sure that we match `en` to `en-US` or `sr` to
 *    `sr-Cyrl`, while `sr-RU` to `sr-Latn-RU`.
 *
 *    This list can be taken directly from CLDR Supplemental Data.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    [&apos;fr&apos;] * [&apos;fr-FR&apos;] = [&apos;fr-FR&apos;]
 *    [&apos;en&apos;] * [&apos;en-US&apos;] = [&apos;en-US&apos;]
 *    [&apos;sr&apos;] * [&apos;sr-Latn&apos;, &apos;sr-Cyrl&apos;] = [&apos;sr-Cyrl&apos;]
 *
 *  3) variant/region range check has been added
 *
 *    Lastly, the last form of check is against the requested locale ID
 *    but with the variant/region field replaced with a `*` range.
 *
 *    The rationale here laid out in LDML 4.4 Language Matching:
 *      &quot;(...) normally the fall-off between the user&apos;s languages is
 *      substantially greated than regional variants.&quot;
 *
 *    In other words, if we can&apos;t match for the given region, maybe
 *    we can match for the same language/script but other region, and
 *    it will in most cases be preferred over falling back on the next
 *    language.
 *
 *    What it does ([requested] * [available] = [supported]):
 *
 *    [&apos;en-AU&apos;] * [&apos;en-US&apos;] = [&apos;en-US&apos;]
 *    [&apos;sr-RU&apos;] * [&apos;sr-Latn-RO&apos;] = [&apos;sr-Latn-RO&apos;] // sr-RU -&gt; sr-Latn-RU
 *
 *    It works similarly to getParentLocales algo, except that we stop
 *    after matching against variant/region ranges and don&apos;t try to match
 *    ignoring script ranges. That means that `sr-Cyrl` will never match
 *    against `sr-Latn`.
 */
export default function filterMatches(
  requestedLocales, availableLocales, strategy
) {
  /* eslint complexity: [&quot;error&quot;, 31]*/
  const supportedLocales = new Set();

  const availableLocalesMap = new Map();

  for (let locale of availableLocales) {
    let newLocale = new Locale(locale);
    if (newLocale.isWellFormed) {
      availableLocalesMap.set(locale, new Locale(locale));
    }
  }

  outer:
  for (const reqLocStr of requestedLocales) {
    const reqLocStrLC = reqLocStr.toLowerCase();
    const requestedLocale = new Locale(reqLocStrLC);

    if (requestedLocale.language === undefined) {
      continue;
    }

    // 1) Attempt to make an exact match
    // Example: `en-US` === `en-US`
    for (const key of availableLocalesMap.keys()) {
      if (reqLocStrLC === key.toLowerCase()) {
        supportedLocales.add(key);
        availableLocalesMap.delete(key);
        if (strategy === &quot;lookup&quot;) {
          return Array.from(supportedLocales);
        } else if (strategy === &quot;filtering&quot;) {
          continue;
        } else {
          continue outer;
        }
      }
    }


    // 2) Attempt to match against the available range
    // This turns `en` into `en-*-*-*` and `en-US` into `en-*-US-*`
    // Example: [&apos;en-US&apos;] * [&apos;en&apos;] = [&apos;en&apos;]
    for (const [key, availableLocale] of availableLocalesMap.entries()) {
      if (availableLocale.matches(requestedLocale, true, false)) {
        supportedLocales.add(key);
        availableLocalesMap.delete(key);
        if (strategy === &quot;lookup&quot;) {
          return Array.from(supportedLocales);
        } else if (strategy === &quot;filtering&quot;) {
          continue;
        } else {
          continue outer;
        }
      }
    }

    // 3) Attempt to retrieve a maximal version of the requested locale ID
    // If data is available, it&apos;ll expand `en` into `en-Latn-US` and
    // `zh` into `zh-Hans-CN`.
    // Example: [&apos;en&apos;] * [&apos;en-GB&apos;, &apos;en-US&apos;] = [&apos;en-US&apos;]
    if (requestedLocale.addLikelySubtags()) {
      for (const [key, availableLocale] of availableLocalesMap.entries()) {
        if (availableLocale.matches(requestedLocale, true, false)) {
          supportedLocales.add(key);
          availableLocalesMap.delete(key);
          if (strategy === &quot;lookup&quot;) {
            return Array.from(supportedLocales);
          } else if (strategy === &quot;filtering&quot;) {
            continue;
          } else {
            continue outer;
          }
        }
      }
    }

    // 4) Attempt to look up for a different variant for the same locale ID
    // Example: [&apos;en-US-mac&apos;] * [&apos;en-US-win&apos;] = [&apos;en-US-win&apos;]
    requestedLocale.clearVariants();

    for (const [key, availableLocale] of availableLocalesMap.entries()) {
      if (availableLocale.matches(requestedLocale, true, true)) {
        supportedLocales.add(key);
        availableLocalesMap.delete(key);
        if (strategy === &quot;lookup&quot;) {
          return Array.from(supportedLocales);
        } else if (strategy === &quot;filtering&quot;) {
          continue;
        } else {
          continue outer;
        }
      }
    }

    // 5) Attempt to match against the likely subtag without region
    // In the example below, addLikelySubtags will turn
    // `zh-Hant` into `zh-Hant-TW` giving `zh-TW` priority match
    // over `zh-CN`.
    //
    // Example: [&apos;zh-Hant-HK&apos;] * [&apos;zh-TW&apos;, &apos;zh-CN&apos;] = [&apos;zh-TW&apos;]
    requestedLocale.clearRegion();

    if (requestedLocale.addLikelySubtags()) {
      for (const [key, availableLocale] of availableLocalesMap.entries()) {
        if (availableLocale.matches(requestedLocale, true, false)) {
          supportedLocales.add(key);
          availableLocalesMap.delete(key);
          if (strategy === &quot;lookup&quot;) {
            return Array.from(supportedLocales);
          } else if (strategy === &quot;filtering&quot;) {
            continue;
          } else {
            continue outer;
          }
        }
      }
    }

    // 6) Attempt to look up for a different region for the same locale ID
    // Example: [&apos;en-US&apos;] * [&apos;en-AU&apos;] = [&apos;en-AU&apos;]
    requestedLocale.clearRegion();

    for (const [key, availableLocale] of availableLocalesMap.entries()) {
      if (availableLocale.matches(requestedLocale, true, true)) {
        supportedLocales.add(key);
        availableLocalesMap.delete(key);
        if (strategy === &quot;lookup&quot;) {
          return Array.from(supportedLocales);
        } else if (strategy === &quot;filtering&quot;) {
          continue;
        } else {
          continue outer;
        }
      }
    }
  }

  return Array.from(supportedLocales);
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
